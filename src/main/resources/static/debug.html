<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Instagram API Debug Console</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f5f0e6;
        --bg-2: #eef6f3;
        --card: rgba(255, 255, 255, 0.86);
        --ink: #1d232d;
        --muted: #5f6b76;
        --accent: #f29f58;
        --accent-2: #2c9caf;
        --accent-3: #244f5d;
        --line: rgba(28, 33, 40, 0.1);
        --shadow: 0 18px 40px rgba(20, 24, 31, 0.12);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Sora", system-ui, -apple-system, sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 0% 0%, #ffe3c7, transparent 45%),
          radial-gradient(circle at 100% 0%, #cfe8e2, transparent 40%),
          linear-gradient(180deg, var(--bg), var(--bg-2));
        display: flex;
        justify-content: center;
        padding: 40px 20px 72px;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: radial-gradient(rgba(36, 79, 93, 0.08) 1px, transparent 0);
        background-size: 24px 24px;
        opacity: 0.4;
        pointer-events: none;
        z-index: 0;
      }

      .container {
        width: min(1200px, 100%);
        z-index: 1;
      }

      .header {
        display: flex;
        gap: 24px;
        align-items: flex-end;
        justify-content: space-between;
        margin-bottom: 20px;
      }

      .header h1 {
        margin: 0 0 8px;
        font-size: clamp(2rem, 2.5vw + 1rem, 3rem);
      }

      .header p {
        margin: 0;
        color: var(--muted);
        max-width: 560px;
      }

      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.2em;
        font-size: 0.72rem;
        color: var(--accent-3);
      }

      .user-box {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 16px;
        padding: 16px;
        min-width: 260px;
        box-shadow: var(--shadow);
      }

      label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
      }

      input,
      select,
      textarea,
      button {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--line);
        padding: 10px 12px;
        font-size: 0.95rem;
        font-family: inherit;
        background: #fff;
        color: var(--ink);
      }

      textarea {
        min-height: 90px;
        resize: vertical;
        font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, monospace;
        font-size: 0.85rem;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: 2px solid rgba(44, 156, 175, 0.35);
        border-color: rgba(44, 156, 175, 0.5);
      }

      .tabs {
        display: inline-flex;
        gap: 6px;
        background: rgba(36, 79, 93, 0.08);
        padding: 6px;
        border-radius: 999px;
        margin-bottom: 20px;
      }

      .tab-btn {
        border: none;
        padding: 10px 18px;
        border-radius: 999px;
        background: transparent;
        color: var(--accent-3);
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .tab-btn.active {
        background: linear-gradient(120deg, var(--accent), var(--accent-2));
        color: #1c2228;
        transform: translateY(-1px);
      }

      .tab-panel {
        display: none;
        animation: fadeUp 0.35s ease both;
      }

      .tab-panel.active {
        display: block;
      }

      .grid {
        display: grid;
        grid-template-columns: minmax(0, 0.95fr) minmax(0, 1.05fr);
        gap: 24px;
      }

      .panel-stack {
        margin-top: 28px;
      }

      .card {
        background: var(--card);
        border-radius: 18px;
        border: 1px solid var(--line);
        box-shadow: var(--shadow);
        padding: 20px;
      }

      .card + .card {
        margin-top: 18px;
      }

      .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
        gap: 12px;
      }

      .card-header h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .badge {
        background: rgba(44, 156, 175, 0.12);
        color: var(--accent-3);
        font-size: 0.75rem;
        font-weight: 600;
        padding: 6px 10px;
        border-radius: 999px;
      }

      .field {
        margin-bottom: 14px;
      }

      .hidden {
        display: none;
      }

      .field-note {
        margin-top: 6px;
        font-size: 0.78rem;
        color: var(--muted);
      }

      .image-preview {
        margin-top: 8px;
        width: 100%;
        max-height: 240px;
        object-fit: contain;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.65);
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .check {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.88rem;
        color: var(--muted);
      }

      .check input {
        width: auto;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
      }

      .btn {
        cursor: pointer;
        border: none;
        background: linear-gradient(120deg, var(--accent), var(--accent-2));
        color: #1c2228;
        font-weight: 600;
        padding: 10px 16px;
        width: auto;
      }

      .btn.secondary {
        background: rgba(36, 79, 93, 0.08);
        color: var(--accent-3);
        border: 1px solid rgba(36, 79, 93, 0.2);
      }

      .status {
        margin-top: 10px;
        font-size: 0.88rem;
        color: var(--muted);
      }

      .status.error {
        color: #b14634;
      }

      .status.success {
        color: #1f7a5a;
      }

      .payload {
        margin-top: 16px;
      }

      .payload-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.88rem;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .copy-btn {
        border: 1px solid rgba(36, 79, 93, 0.2);
        background: rgba(36, 79, 93, 0.08);
        color: var(--accent-3);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 0.75rem;
        cursor: pointer;
        width: auto;
      }

      .block {
        margin-bottom: 18px;
      }

      .block-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      .block-header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .chip {
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(44, 156, 175, 0.12);
        border: 1px solid rgba(44, 156, 175, 0.35);
        font-size: 0.82rem;
      }

      .chip.alt {
        background: rgba(242, 159, 88, 0.15);
        border-color: rgba(242, 159, 88, 0.4);
      }

      .raw {
        background: #1c232b;
        color: #f8f4ee;
        padding: 14px;
        border-radius: 12px;
        font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, monospace;
        font-size: 0.8rem;
        white-space: pre-wrap;
        word-break: break-word;
        min-height: 80px;
        margin: 0;
      }

      .raw-tree {
        white-space: normal;
      }

      .json-node {
        margin: 0;
      }

      .json-summary {
        cursor: pointer;
        list-style: none;
        color: #cfe6e1;
        font-weight: 600;
      }

      .json-summary::-webkit-details-marker {
        display: none;
      }

      .json-summary::before {
        content: "▸";
        display: inline-block;
        margin-right: 8px;
        color: #9ad1d6;
      }

      .json-node[open] > .json-summary::before {
        content: "▾";
      }

      .json-children {
        margin-top: 6px;
        margin-left: 18px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .json-leaf {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .json-key {
        color: #f5c48a;
        font-weight: 600;
      }

      .json-type {
        color: #9ad1d6;
      }

      .json-count {
        color: #7c9099;
        margin-left: 4px;
      }

      .json-value {
        color: #d7dee3;
      }

      .json-value.string {
        color: #b7e3c7;
      }

      .json-value.number {
        color: #f2b48f;
      }

      .json-value.boolean {
        color: #f29f58;
      }

      .json-value.null {
        color: #9aa7b2;
      }

      .list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .list-item {
        border: 1px solid rgba(36, 79, 93, 0.15);
        background: rgba(255, 255, 255, 0.72);
        border-radius: 14px;
        padding: 12px 14px;
      }

      .list-primary {
        font-weight: 600;
      }

      .list-meta {
        margin-top: 4px;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .list-empty {
        color: var(--muted);
        font-size: 0.9rem;
      }

      @keyframes fadeUp {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 960px) {
        .header {
          flex-direction: column;
          align-items: flex-start;
        }

        .user-box {
          width: 100%;
        }

        .grid {
          grid-template-columns: 1fr;
        }

        .row {
          grid-template-columns: 1fr;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .tab-panel {
          animation: none;
        }

        .tab-btn.active {
          transform: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header class="header">
        <div>
          <div class="eyebrow">Instagram API Debug</div>
          <h1>Debug Console</h1>
          <p>
            Full coverage for InstagramController. Test profiles, prompts, DM generation, and keyword search flows.
          </p>
        </div>
        <div class="user-box">
          <label for="userId">Instagram Username</label>
          <input id="userId" type="text" placeholder="e.g. minD3D" />
        </div>
      </header>

      <div class="tabs" role="tablist">
        <button class="tab-btn active" data-tab="profiles" type="button">Profiles</button>
        <button class="tab-btn" data-tab="keywords" type="button">Keyword Extract</button>
        <button class="tab-btn" data-tab="price" type="button">Price Extract</button>
        <button class="tab-btn" data-tab="dm" type="button">DM Message</button>
        <button class="tab-btn" data-tab="search" type="button">Search</button>
        <button class="tab-btn" data-tab="featuring" type="button">Featuring</button>
      </div>

      <section class="tab-panel active" data-panel="profiles">
        <div class="grid">
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Request</h2>
                <span class="badge">POST /instagram/profiles | /profile-details | /profile-cache | GET /instagram/profile-by-username</span>
              </div>
              <div class="field">
                <label for="profileEndpoint">Endpoint</label>
                <select id="profileEndpoint">
                  <option value="profiles">/instagram/profiles</option>
                  <option value="profile-details">/instagram/profile-details</option>
                  <option value="profile-cache">/instagram/profile-cache</option>
                  <option value="profile-by-username">/instagram/profile-by-username (GET)</option>
                </select>
                <div class="field-note">Uses the shared Instagram Username input. The GET endpoint uses a query param.</div>
              </div>
              <div class="actions">
                <button class="btn" id="profileBtn" type="button">Send Request</button>
              </div>
              <div class="status" id="profileStatus">Idle.</div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request URL</span>
                  <button class="copy-btn" data-copy="profile-url" type="button">Copy</button>
                </div>
                <textarea id="profileUrlOutput" rows="2" readonly></textarea>
              </div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request JSON</span>
                  <button class="copy-btn" data-copy="profile-request" type="button">Copy</button>
                </div>
                <textarea id="profileRequestOutput" rows="4" readonly></textarea>
              </div>
            </div>
            <div class="card">
              <div class="card-header">
                <h2>Batch Fetch</h2>
                <span class="badge">GET /instagram/profile-by-username</span>
              </div>
              <div class="field">
                <label for="batchUsernames">Username List</label>
                <textarea
                  id="batchUsernames"
                  rows="6"
                  placeholder="one username per line, or comma-separated"
                ></textarea>
                <div class="field-note">Requests are spaced by a random 1-10 second delay.</div>
              </div>
              <div class="actions">
                <button class="btn" id="batchProfileBtn" type="button">Start Batch</button>
                <button class="btn secondary" id="batchProfileStopBtn" type="button">Stop</button>
              </div>
              <div class="status" id="batchProfileStatus">Idle.</div>
              <div class="payload">
                <div class="payload-header">
                  <span>Batch Results</span>
                  <button class="copy-btn" data-copy="batch-profile-raw" type="button">Copy</button>
                </div>
                <div class="raw raw-tree" id="batchProfileRawOutput"></div>
              </div>
            </div>
          </div>
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Response</h2>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Raw Response</h3>
                  <button class="copy-btn" data-copy="profile-raw" type="button">Copy</button>
                </div>
                <div class="raw raw-tree" id="profileRawOutput"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-panel="keywords">
        <div class="grid">
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Request</h2>
                <span class="badge">POST /instagram/extract-keywords</span>
              </div>
              <div class="field">
                <label for="keywordVersion">Prompt Version</label>
                <select id="keywordVersion"></select>
              </div>
              <div class="field hidden" id="keywordCustomPromptField">
                <label for="customKeywordPrompt">Custom Keyword Prompt</label>
                <textarea
                  id="customKeywordPrompt"
                  rows="6"
                  placeholder="Paste a custom keyword prompt template."
                ></textarea>
                <div class="field-note">
                  Use {{profile_name}}, {{profile_bio}}, {{profile_category}}, {{post_captions}} placeholders.
                </div>
              </div>
              <label class="check">
                <input id="keywordIgnoreCache" type="checkbox" />
                ignoreCache
              </label>
              <div class="actions">
                <button class="btn" id="keywordBtn" type="button">Extract Keywords</button>
                <button class="btn secondary" id="promptBtn" type="button">Fetch Prompt Preview</button>
              </div>
              <div class="status" id="keywordStatus">Idle.</div>
              <div class="status" id="promptStatus"></div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request JSON</span>
                  <button class="copy-btn" data-copy="keyword-request" type="button">Copy</button>
                </div>
                <textarea id="keywordRequestOutput" rows="7" readonly></textarea>
              </div>
            </div>
            <div class="card">
              <div class="card-header">
                <h2>Keyword Versions</h2>
                <span class="badge">GET /instagram/keyword-versions</span>
              </div>
              <div class="actions">
                <button class="btn secondary" id="keywordVersionsBtn" type="button">Refresh Versions</button>
              </div>
              <div class="status" id="keywordVersionsStatus">Loaded on page load.</div>
              <div class="payload">
                <div class="payload-header">
                  <span>Response JSON</span>
                  <button class="copy-btn" data-copy="keyword-versions" type="button">Copy</button>
                </div>
                <textarea id="keywordVersionsOutput" rows="4" readonly></textarea>
              </div>
            </div>
          </div>
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Response</h2>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Keywords</h3>
                  <button class="copy-btn" data-copy="keywords" type="button">Copy</button>
                </div>
                <div class="chips" id="keywordChips"></div>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Prompt Template</h3>
                  <button class="copy-btn" data-copy="template" type="button">Copy</button>
                </div>
                <textarea id="templateOutput" rows="6" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Prompt Preview</h3>
                  <button class="copy-btn" data-copy="prompt" type="button">Copy</button>
                </div>
                <textarea id="promptOutput" rows="6" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Raw Response</h3>
                  <button class="copy-btn" data-copy="keyword-raw" type="button">Copy</button>
                </div>
                <div class="raw raw-tree" id="keywordRawOutput"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-panel="price">
        <div class="grid">
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Request</h2>
                <span class="badge">POST /instagram/extract-prices</span>
              </div>
              <div class="field">
                <label for="priceText">Input Text</label>
                <textarea id="priceText" rows="6" placeholder="Optional text context or OCR."></textarea>
              </div>
              <div class="field">
                <label for="priceImageUrl">Image URL</label>
                <input
                  id="priceImageUrl"
                  type="text"
                  placeholder="https://... or data:image/png;base64,..."
                />
                <div class="field-note">Paste a public image URL or a data URI.</div>
              </div>
              <div class="field">
                <label for="priceImageFile">Image File</label>
                <input id="priceImageFile" type="file" accept="image/*" />
                <div class="field-note" id="priceImageFileNote">No file selected.</div>
              </div>
              <div class="field hidden" id="priceImagePreviewWrap">
                <label>Preview</label>
                <img id="priceImagePreview" class="image-preview" alt="Selected image preview" />
              </div>
              <div class="field">
                <label for="priceVersion">Prompt Version</label>
                <select id="priceVersion"></select>
              </div>
              <div class="field hidden" id="priceCustomPromptField">
                <label for="customPricePrompt">Custom Price Prompt</label>
                <textarea
                  id="customPricePrompt"
                  rows="6"
                  placeholder="Paste a custom price prompt template."
                ></textarea>
                <div class="field-note">Use {{input_text}} placeholder for input text.</div>
              </div>
              <div class="actions">
                <button class="btn" id="priceBtn" type="button">Extract Prices</button>
                <button class="btn secondary" id="pricePromptBtn" type="button">Fetch Prompt Preview</button>
              </div>
              <div class="status" id="priceStatus">Idle.</div>
              <div class="status" id="pricePromptStatus"></div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request JSON</span>
                  <button class="copy-btn" data-copy="price-request" type="button">Copy</button>
                </div>
                <textarea id="priceRequestOutput" rows="7" readonly></textarea>
              </div>
            </div>
            <div class="card">
              <div class="card-header">
                <h2>Price Versions</h2>
                <span class="badge">GET /instagram/price-versions</span>
              </div>
              <div class="actions">
                <button class="btn secondary" id="priceVersionsBtn" type="button">Refresh Versions</button>
              </div>
              <div class="status" id="priceVersionsStatus">Loaded on page load.</div>
              <div class="payload">
                <div class="payload-header">
                  <span>Response JSON</span>
                  <button class="copy-btn" data-copy="price-versions" type="button">Copy</button>
                </div>
                <textarea id="priceVersionsOutput" rows="4" readonly></textarea>
              </div>
            </div>
          </div>
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Response</h2>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Price Output</h3>
                  <button class="copy-btn" data-copy="price-json" type="button">Copy</button>
                </div>
                <textarea id="priceOutput" rows="10" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Prompt Template</h3>
                  <button class="copy-btn" data-copy="price-template" type="button">Copy</button>
                </div>
                <textarea id="priceTemplateOutput" rows="6" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Prompt Preview</h3>
                  <button class="copy-btn" data-copy="price-prompt" type="button">Copy</button>
                </div>
                <textarea id="pricePromptOutput" rows="6" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>OpenAI Payload</h3>
                  <button class="copy-btn" data-copy="price-payload" type="button">Copy</button>
                </div>
                <textarea id="pricePayloadOutput" rows="8" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Raw Response</h3>
                  <button class="copy-btn" data-copy="price-raw" type="button">Copy</button>
                </div>
                <div class="raw raw-tree" id="priceRawOutput"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-panel="dm">
        <div class="grid">
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Request</h2>
                <span class="badge">POST /instagram/generate-dm</span>
              </div>
              <div class="field">
                <label for="dmKeywordVersion">Keyword Version</label>
                <select id="dmKeywordVersion"></select>
              </div>
              <div class="field hidden" id="dmKeywordCustomPromptField">
                <label for="customDmKeywordPrompt">Custom Keyword Prompt</label>
                <textarea
                  id="customDmKeywordPrompt"
                  rows="5"
                  placeholder="Custom keyword prompt template for DM flow."
                ></textarea>
                <div class="field-note">
                  Use {{profile_name}}, {{profile_bio}}, {{profile_category}}, {{post_captions}} placeholders.
                </div>
              </div>
              <div class="field">
                <label for="dmVersion">DM Prompt Version</label>
                <select id="dmVersion"></select>
              </div>
              <div class="field hidden" id="dmCustomPromptField">
                <label for="customDmPrompt">Custom DM Prompt</label>
                <textarea id="customDmPrompt" rows="5" placeholder="Custom DM prompt template."></textarea>
                <div class="field-note">
                  Use {{MOOD_KEYWORDS}}, {{CONTENT_KEYWORDS}}, {{TONE_KEYWORDS}}, {{IMPRESSION_SUMMARY}}
                  placeholders.
                </div>
              </div>
              <label class="check">
                <input id="dmIgnoreCache" type="checkbox" />
                ignoreCache
              </label>
              <div class="actions">
                <button class="btn" id="dmBtn" type="button">Generate DM</button>
                <button class="btn secondary" id="dmPromptBtn" type="button">Fetch DM Prompt</button>
              </div>
              <div class="status" id="dmStatus">Idle.</div>
              <div class="status" id="dmPromptStatus"></div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request JSON</span>
                  <button class="copy-btn" data-copy="dm-request" type="button">Copy</button>
                </div>
                <textarea id="dmRequestOutput" rows="7" readonly></textarea>
              </div>
            </div>
            <div class="card">
              <div class="card-header">
                <h2>DM Versions</h2>
                <span class="badge">GET /instagram/dm-versions</span>
              </div>
              <div class="actions">
                <button class="btn secondary" id="dmVersionsBtn" type="button">Refresh Versions</button>
              </div>
              <div class="status" id="dmVersionsStatus">Loaded on page load.</div>
              <div class="payload">
                <div class="payload-header">
                  <span>Response JSON</span>
                  <button class="copy-btn" data-copy="dm-versions" type="button">Copy</button>
                </div>
                <textarea id="dmVersionsOutput" rows="4" readonly></textarea>
              </div>
            </div>
          </div>
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Response</h2>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>DM Message</h3>
                  <button class="copy-btn" data-copy="dm" type="button">Copy</button>
                </div>
                <textarea id="dmOutput" rows="6" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Mood Keywords</h3>
                </div>
                <div class="chips" id="dmMoodChips"></div>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Content Keywords</h3>
                </div>
                <div class="chips" id="dmContentChips"></div>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Tone Keywords</h3>
                </div>
                <div class="chips" id="dmToneChips"></div>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Impression Summary</h3>
                  <button class="copy-btn" data-copy="dm-summary" type="button">Copy</button>
                </div>
                <textarea id="dmSummaryOutput" rows="4" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>DM Prompt Template</h3>
                  <button class="copy-btn" data-copy="dm-prompt" type="button">Copy</button>
                </div>
                <textarea id="dmPromptOutput" rows="6" readonly></textarea>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Raw Response</h3>
                  <button class="copy-btn" data-copy="dm-raw" type="button">Copy</button>
                </div>
                <div class="raw raw-tree" id="dmRawOutput"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-panel="search">
        <div class="grid panel-stack">
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Request</h2>
                <span class="badge">GET /instagram/search/keyword/users | /expand</span>
              </div>
              <div class="field">
                <label for="keywordQuery">Keyword Query</label>
                <input
                  id="keywordQuery"
                  type="text"
                  placeholder="e.g. #뷰티 or 뷰티"
                />
                <div class="field-note">Include # if you want hashtag-style results.</div>
              </div>
              <label class="check">
                <input id="keywordUserExpand" type="checkbox" checked />
                expand via hashtag feed
              </label>
              <div class="row" id="keywordUserOptions">
                <div class="field">
                  <label for="keywordUserMax">Max Users</label>
                  <input id="keywordUserMax" type="number" min="1" max="200" value="60" />
                </div>
                <div class="field">
                  <label for="keywordUserFeedCount">Feed Count</label>
                  <input id="keywordUserFeedCount" type="number" min="1" max="50" value="30" />
                </div>
                <div class="field">
                  <label for="keywordUserPages">Pages</label>
                  <input id="keywordUserPages" type="number" min="1" max="10" value="1" />
                </div>
              </div>
              <div class="actions">
                <button class="btn" id="keywordUserBtn" type="button">Fetch Users</button>
              </div>
              <div class="status" id="keywordUserStatus">Idle.</div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request URL</span>
                  <button class="copy-btn" data-copy="keyword-users-request" type="button">Copy</button>
                </div>
                <textarea id="keywordUserRequestOutput" rows="3" readonly></textarea>
              </div>
            </div>
          </div>
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Response</h2>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>User List</h3>
                  <button class="copy-btn" data-copy="keyword-users" type="button">Copy</button>
                </div>
                <div class="list" id="keywordUserList"></div>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Raw Response</h3>
                  <button class="copy-btn" data-copy="keyword-users-raw" type="button">Copy</button>
                </div>
                <div class="raw raw-tree" id="keywordUserRawOutput"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-panel="featuring">
        <div class="grid panel-stack">
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Request</h2>
                <span class="badge">GET /featuring/influencers</span>
              </div>
              <div class="field">
                <label for="featuringCurl">Prefill From curl</label>
                <textarea
                  id="featuringCurl"
                  rows="4"
                  placeholder="Paste curl here to auto-fill platform, page, sort, workspace, cookie."
                ></textarea>
                <div class="actions">
                  <button class="btn secondary" id="featuringParseBtn" type="button">Parse curl</button>
                  <label class="check">
                    <input id="featuringRemember" type="checkbox" checked />
                    remember in browser
                  </label>
                </div>
                <div class="field-note">Keeps values in localStorage on this machine only.</div>
              </div>
              <div class="row">
                <div class="field">
                  <label for="featuringPlatform">Platform</label>
                  <select id="featuringPlatform">
                    <option value="ig" selected>ig</option>
                    <option value="yt">yt</option>
                    <option value="nb">nb</option>
                    <option value="tt">tt</option>
                    <option value="tw">tw</option>
                  </select>
                </div>
                <div class="field">
                  <label for="featuringPage">Page</label>
                  <input id="featuringPage" type="number" min="1" value="1" />
                </div>
              </div>
              <div class="row">
                <div class="field">
                  <label for="featuringSortField">Order By</label>
                  <input id="featuringSortField" type="text" value="follower" />
                </div>
                <div class="field">
                  <label for="featuringSortOrder">Order</label>
                  <select id="featuringSortOrder">
                    <option value="desc" selected>desc</option>
                    <option value="asc">asc</option>
                  </select>
                </div>
              </div>
              <div class="field">
                <label for="featuringWorkspace">Ft-Workspace Header</label>
                <input id="featuringWorkspace" type="text" placeholder="workspace code" />
                <div class="field-note">Required for Featuring API access.</div>
              </div>
              <div class="field">
                <label for="featuringAuthorization">Authorization (Bearer)</label>
                <textarea
                  id="featuringAuthorization"
                  rows="3"
                  placeholder="Bearer eyJhbGciOi..."
                ></textarea>
                <div class="field-note">Sent as X-Featuring-Authorization.</div>
              </div>
              <div class="field">
                <label for="featuringCookie">Cookie Header (optional)</label>
                <textarea
                  id="featuringCookie"
                  rows="5"
                  placeholder="Paste the full cookie string from your curl request."
                ></textarea>
                <div class="field-note">Sent as X-Featuring-Cookie (browsers cannot set Cookie directly).</div>
              </div>
              <div class="actions">
                <button class="btn" id="featuringBtn" type="button">Fetch Influencers</button>
              </div>
              <div class="status" id="featuringStatus">Idle.</div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request URL</span>
                  <button class="copy-btn" data-copy="featuring-url" type="button">Copy</button>
                </div>
                <textarea id="featuringRequestOutput" rows="3" readonly></textarea>
              </div>
              <div class="payload">
                <div class="payload-header">
                  <span>Request Headers</span>
                  <button class="copy-btn" data-copy="featuring-headers" type="button">Copy</button>
                </div>
                <textarea id="featuringHeadersOutput" rows="6" readonly></textarea>
              </div>
            </div>
          </div>
          <div>
            <div class="card">
              <div class="card-header">
                <h2>Response</h2>
              </div>
              <div class="block">
                <div class="block-header">
                  <h3>Raw Response</h3>
                  <button class="copy-btn" data-copy="featuring-raw" type="button">Copy</button>
                </div>
                <div class="raw raw-tree" id="featuringRawOutput"></div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      const userIdInput = document.getElementById("userId");
      const profileEndpointSelect = document.getElementById("profileEndpoint");
      const profileBtn = document.getElementById("profileBtn");
      const profileStatusEl = document.getElementById("profileStatus");
      const profileRequestOutput = document.getElementById("profileRequestOutput");
      const profileUrlOutput = document.getElementById("profileUrlOutput");
      const profileRawOutput = document.getElementById("profileRawOutput");
      const batchUsernamesInput = document.getElementById("batchUsernames");
      const batchProfileBtn = document.getElementById("batchProfileBtn");
      const batchProfileStopBtn = document.getElementById("batchProfileStopBtn");
      const batchProfileStatusEl = document.getElementById("batchProfileStatus");
      const batchProfileRawOutput = document.getElementById("batchProfileRawOutput");
      const keywordVersionSelect = document.getElementById("keywordVersion");
      const keywordCustomPromptField = document.getElementById("keywordCustomPromptField");
      const customKeywordPromptInput = document.getElementById("customKeywordPrompt");
      const keywordIgnoreCache = document.getElementById("keywordIgnoreCache");
      const keywordRequestOutput = document.getElementById("keywordRequestOutput");
      const keywordBtn = document.getElementById("keywordBtn");
      const promptBtn = document.getElementById("promptBtn");
      const keywordStatusEl = document.getElementById("keywordStatus");
      const promptStatusEl = document.getElementById("promptStatus");
      const keywordChips = document.getElementById("keywordChips");
      const templateOutput = document.getElementById("templateOutput");
      const promptOutput = document.getElementById("promptOutput");
      const keywordRawOutput = document.getElementById("keywordRawOutput");
      const keywordVersionsBtn = document.getElementById("keywordVersionsBtn");
      const keywordVersionsStatusEl = document.getElementById("keywordVersionsStatus");
      const keywordVersionsOutput = document.getElementById("keywordVersionsOutput");

      const priceTextInput = document.getElementById("priceText");
      const priceImageUrlInput = document.getElementById("priceImageUrl");
      const priceImageFileInput = document.getElementById("priceImageFile");
      const priceImageFileNote = document.getElementById("priceImageFileNote");
      const priceImagePreviewWrap = document.getElementById("priceImagePreviewWrap");
      const priceImagePreview = document.getElementById("priceImagePreview");
      const priceVersionSelect = document.getElementById("priceVersion");
      const priceCustomPromptField = document.getElementById("priceCustomPromptField");
      const customPricePromptInput = document.getElementById("customPricePrompt");
      const priceRequestOutput = document.getElementById("priceRequestOutput");
      const priceBtn = document.getElementById("priceBtn");
      const pricePromptBtn = document.getElementById("pricePromptBtn");
      const priceStatusEl = document.getElementById("priceStatus");
      const pricePromptStatusEl = document.getElementById("pricePromptStatus");
      const priceOutput = document.getElementById("priceOutput");
      const priceTemplateOutput = document.getElementById("priceTemplateOutput");
      const pricePromptOutput = document.getElementById("pricePromptOutput");
      const pricePayloadOutput = document.getElementById("pricePayloadOutput");
      const priceRawOutput = document.getElementById("priceRawOutput");
      const priceVersionsBtn = document.getElementById("priceVersionsBtn");
      const priceVersionsStatusEl = document.getElementById("priceVersionsStatus");
      const priceVersionsOutput = document.getElementById("priceVersionsOutput");

      const dmKeywordVersionSelect = document.getElementById("dmKeywordVersion");
      const dmKeywordCustomPromptField = document.getElementById("dmKeywordCustomPromptField");
      const customDmKeywordPromptInput = document.getElementById("customDmKeywordPrompt");
      const dmVersionSelect = document.getElementById("dmVersion");
      const dmCustomPromptField = document.getElementById("dmCustomPromptField");
      const customDmPromptInput = document.getElementById("customDmPrompt");
      const dmIgnoreCache = document.getElementById("dmIgnoreCache");
      const dmRequestOutput = document.getElementById("dmRequestOutput");
      const dmBtn = document.getElementById("dmBtn");
      const dmStatusEl = document.getElementById("dmStatus");
      const dmOutput = document.getElementById("dmOutput");
      const dmMoodChips = document.getElementById("dmMoodChips");
      const dmContentChips = document.getElementById("dmContentChips");
      const dmToneChips = document.getElementById("dmToneChips");
      const dmSummaryOutput = document.getElementById("dmSummaryOutput");
      const dmPromptBtn = document.getElementById("dmPromptBtn");
      const dmPromptStatusEl = document.getElementById("dmPromptStatus");
      const dmPromptOutput = document.getElementById("dmPromptOutput");
      const dmVersionsBtn = document.getElementById("dmVersionsBtn");
      const dmVersionsStatusEl = document.getElementById("dmVersionsStatus");
      const dmVersionsOutput = document.getElementById("dmVersionsOutput");
      const dmRawOutput = document.getElementById("dmRawOutput");

      const keywordQueryInput = document.getElementById("keywordQuery");
      const keywordUserExpand = document.getElementById("keywordUserExpand");
      const keywordUserOptions = document.getElementById("keywordUserOptions");
      const keywordUserMax = document.getElementById("keywordUserMax");
      const keywordUserFeedCount = document.getElementById("keywordUserFeedCount");
      const keywordUserPages = document.getElementById("keywordUserPages");
      const keywordUserBtn = document.getElementById("keywordUserBtn");
      const keywordUserStatusEl = document.getElementById("keywordUserStatus");
      const keywordUserRequestOutput = document.getElementById("keywordUserRequestOutput");
      const keywordUserList = document.getElementById("keywordUserList");
      const keywordUserRawOutput = document.getElementById("keywordUserRawOutput");

      const featuringPlatform = document.getElementById("featuringPlatform");
      const featuringPage = document.getElementById("featuringPage");
      const featuringSortField = document.getElementById("featuringSortField");
      const featuringSortOrder = document.getElementById("featuringSortOrder");
      const featuringWorkspace = document.getElementById("featuringWorkspace");
      const featuringCookie = document.getElementById("featuringCookie");
      const featuringAuthorization = document.getElementById("featuringAuthorization");
      const featuringCurl = document.getElementById("featuringCurl");
      const featuringParseBtn = document.getElementById("featuringParseBtn");
      const featuringRemember = document.getElementById("featuringRemember");
      const featuringBtn = document.getElementById("featuringBtn");
      const featuringStatusEl = document.getElementById("featuringStatus");
      const featuringRequestOutput = document.getElementById("featuringRequestOutput");
      const featuringHeadersOutput = document.getElementById("featuringHeadersOutput");
      const featuringRawOutput = document.getElementById("featuringRawOutput");

      const tabButtons = document.querySelectorAll(".tab-btn");
      const tabPanels = document.querySelectorAll(".tab-panel");
      const copyButtons = document.querySelectorAll("[data-copy]");
      const DEFAULT_KEYWORD_VERSION = "v2";
      const DEFAULT_PRICE_VERSION = "v1";
      const DEFAULT_DM_VERSION = "v1";
      let lastKeywordVersion = DEFAULT_KEYWORD_VERSION;
      let lastPriceVersion = DEFAULT_PRICE_VERSION;
      let lastDmKeywordVersion = DEFAULT_KEYWORD_VERSION;
      let lastDmVersion = DEFAULT_DM_VERSION;
      let priceImageDataUrl = "";
      let lastPricePrompt = "";
      let batchAbortController = null;
      let batchInFlight = false;
      let batchResults = [];

      function getCustomPrompt(selectEl, inputEl) {
        if (selectEl.value !== "custom") {
          return "";
        }
        const value = inputEl.value;
        return value.trim() ? value : "";
      }

      function resolveVersion(selectEl, lastValue, fallback) {
        if (selectEl.value && selectEl.value !== "custom") {
          return selectEl.value;
        }
        return lastValue || fallback;
      }

      function toggleCustomField(selectEl, fieldEl) {
        if (!fieldEl) {
          return;
        }
        fieldEl.classList.toggle("hidden", selectEl.value !== "custom");
      }

      function syncLastVersions() {
        if (keywordVersionSelect.value !== "custom") {
          lastKeywordVersion = keywordVersionSelect.value;
        }
        if (priceVersionSelect.value !== "custom") {
          lastPriceVersion = priceVersionSelect.value;
        }
        if (dmKeywordVersionSelect.value !== "custom") {
          lastDmKeywordVersion = dmKeywordVersionSelect.value;
        }
        if (dmVersionSelect.value !== "custom") {
          lastDmVersion = dmVersionSelect.value;
        }
      }

      function isProfileGetEndpoint(endpoint) {
        return endpoint === "profile-by-username";
      }

      function parseBatchUsernames(value) {
        const parts = (value || "").split(/[\n,]+/);
        const seen = new Set();
        const results = [];
        parts.forEach((part) => {
          const trimmed = part.trim();
          if (!trimmed || seen.has(trimmed)) {
            return;
          }
          seen.add(trimmed);
          results.push(trimmed);
        });
        return results;
      }

      function randomDelayMs() {
        return 1000 + Math.floor(Math.random() * 9001);
      }

      function wait(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function setBatchControls(running) {
        batchProfileBtn.disabled = running;
        batchProfileStopBtn.disabled = !running;
      }

      function buildProfilePayload() {
        const endpoint = profileEndpointSelect.value || "profiles";
        const username = userIdInput.value.trim();
        if (isProfileGetEndpoint(endpoint)) {
          return {
            username,
          };
        }
        return {
          userId: username,
        };
      }

      function buildProfileUrl() {
        const endpoint = profileEndpointSelect.value || "profiles";
        if (isProfileGetEndpoint(endpoint)) {
          const username = userIdInput.value.trim();
          const params = new URLSearchParams({ username });
          return "/instagram/" + endpoint + "?" + params.toString();
        }
        return "/instagram/" + endpoint;
      }

      function buildKeywordPayload() {
        return {
          userId: userIdInput.value.trim(),
          version: resolveVersion(keywordVersionSelect, lastKeywordVersion, DEFAULT_KEYWORD_VERSION),
          customPrompt: getCustomPrompt(keywordVersionSelect, customKeywordPromptInput),
          ignoreCache: keywordIgnoreCache.checked,
        };
      }

      function buildPricePayload() {
        const resolvedImageUrl = priceImageDataUrl || priceImageUrlInput.value.trim();
        return {
          text: priceTextInput.value.trim(),
          imageUrl: resolvedImageUrl,
          version: resolveVersion(priceVersionSelect, lastPriceVersion, DEFAULT_PRICE_VERSION),
          customPrompt: getCustomPrompt(priceVersionSelect, customPricePromptInput),
        };
      }

      function buildDmPayload() {
        return {
          userId: userIdInput.value.trim(),
          version: resolveVersion(dmKeywordVersionSelect, lastDmKeywordVersion, DEFAULT_KEYWORD_VERSION),
          customKeywordPrompt: getCustomPrompt(dmKeywordVersionSelect, customDmKeywordPromptInput),
          dmVersion: resolveVersion(dmVersionSelect, lastDmVersion, DEFAULT_DM_VERSION),
          customDmPrompt: getCustomPrompt(dmVersionSelect, customDmPromptInput),
          ignoreCache: dmIgnoreCache.checked,
        };
      }

      function setRequestPreview(target, payload) {
        target.value = JSON.stringify(payload, null, 2);
      }

      function buildPriceOpenAiPayload(promptText) {
        const payload = {
          model: "(server-configured)",
          input: [
            {
              role: "user",
              content: [
                {
                  type: "input_text",
                  text: promptText || "",
                },
              ],
            },
          ],
        };
        const imageUrl = buildPricePayload().imageUrl;
        if (imageUrl) {
          payload.input[0].content.push({
            type: "input_image",
            image_url: imageUrl,
          });
        }
        return payload;
      }

      function updatePricePayloadPreview() {
        if (!lastPricePrompt) {
          pricePayloadOutput.value = "";
          return;
        }
        pricePayloadOutput.value = JSON.stringify(buildPriceOpenAiPayload(lastPricePrompt), null, 2);
      }

      function setRawOutput(target, text) {
        const safeText = text || "(empty response)";
        target.innerHTML = "";
        try {
          const parsed = JSON.parse(safeText);
          const pretty = JSON.stringify(parsed, null, 2);
          target.dataset.raw = pretty;
          target.appendChild(createJsonNode(parsed, null, 0));
        } catch (err) {
          target.dataset.raw = safeText;
          target.textContent = safeText;
        }
      }

      function createJsonNode(value, keyLabel, depth) {
        const isArray = Array.isArray(value);
        const isObject = value !== null && typeof value === "object" && !isArray;
        if (isArray || isObject) {
          const details = document.createElement("details");
          details.className = "json-node";
          details.open = true;

          const summary = document.createElement("summary");
          summary.className = "json-summary";
          const keySpan = document.createElement("span");
          keySpan.className = "json-key";
          const typeSpan = document.createElement("span");
          typeSpan.className = "json-type";
          const countSpan = document.createElement("span");
          countSpan.className = "json-count";
          const count = isArray ? value.length : Object.keys(value).length;

          if (keyLabel) {
            keySpan.textContent = keyLabel;
            summary.appendChild(keySpan);
            summary.appendChild(document.createTextNode(": "));
          }
          typeSpan.textContent = isArray ? "Array" : "Object";
          countSpan.textContent = "(" + count + ")";
          summary.appendChild(typeSpan);
          summary.appendChild(document.createTextNode(" "));
          summary.appendChild(countSpan);

          const children = document.createElement("div");
          children.className = "json-children";
          if (isArray) {
            value.forEach((item, index) => {
              children.appendChild(createJsonNode(item, "[" + index + "]", depth + 1));
            });
          } else {
            Object.keys(value).forEach((key) => {
              const label = "\"" + key + "\"";
              children.appendChild(createJsonNode(value[key], label, depth + 1));
            });
          }

          details.appendChild(summary);
          details.appendChild(children);
          return details;
        }

        const line = document.createElement("div");
        line.className = "json-leaf";
        if (keyLabel) {
          const keySpan = document.createElement("span");
          keySpan.className = "json-key";
          keySpan.textContent = keyLabel;
          line.appendChild(keySpan);
          line.appendChild(document.createTextNode(": "));
        }
        const valueSpan = document.createElement("span");
        valueSpan.className = "json-value";
        if (value === null) {
          valueSpan.classList.add("null");
          valueSpan.textContent = "null";
        } else if (typeof value === "string") {
          valueSpan.classList.add("string");
          valueSpan.textContent = "\"" + value + "\"";
        } else if (typeof value === "number") {
          valueSpan.classList.add("number");
          valueSpan.textContent = String(value);
        } else if (typeof value === "boolean") {
          valueSpan.classList.add("boolean");
          valueSpan.textContent = String(value);
        } else {
          valueSpan.textContent = String(value);
        }
        line.appendChild(valueSpan);
        return line;
      }

      function buildKeywordUserRequestUrl() {
        const query = keywordQueryInput.value.trim();
        if (!query) {
          return "";
        }
        if (!keywordUserExpand.checked) {
          return "/instagram/search/keyword/users?q=" + encodeURIComponent(query);
        }
        const maxUsers = parseInt(keywordUserMax.value, 10);
        const feedCount = parseInt(keywordUserFeedCount.value, 10);
        const pages = parseInt(keywordUserPages.value, 10);
        const resolvedMax = Number.isFinite(maxUsers) && maxUsers > 0 ? maxUsers : 60;
        const resolvedFeed = Number.isFinite(feedCount) && feedCount > 0 ? feedCount : 30;
        const resolvedPages = Number.isFinite(pages) && pages > 0 ? pages : 1;
        const params = new URLSearchParams({
          q: query,
          maxUsers: String(resolvedMax),
          feedCount: String(resolvedFeed),
          pages: String(resolvedPages),
        });
        return "/instagram/search/keyword/users/expand?" + params.toString();
      }

      function buildFeaturingRequestUrl() {
        const platform = (featuringPlatform.value || "ig").trim() || "ig";
        const rawPage = parseInt(featuringPage.value, 10);
        const page = Number.isFinite(rawPage) && rawPage > 0 ? rawPage : 1;
        const sortField = featuringSortField.value.trim() || "follower";
        const sortOrder = (featuringSortOrder.value || "desc").trim() || "desc";
        const params = new URLSearchParams({
          page: String(page),
          order: sortOrder,
          order_by: sortField,
        });
        return "/featuring/influencers?platform=" + encodeURIComponent(platform) + "&" + params.toString();
      }

      function buildFeaturingHeaders() {
        const headers = {};
        const workspace = featuringWorkspace.value.trim();
        if (workspace) {
          headers["Ft-Workspace"] = workspace;
        }
        const authorization = featuringAuthorization.value.trim();
        if (authorization) {
          headers["X-Featuring-Authorization"] = authorization;
        }
        const cookie = featuringCookie.value.trim();
        if (cookie) {
          headers["X-Featuring-Cookie"] = cookie;
        }
        return headers;
      }

      function parseCurlInput(text) {
        const result = {
          url: "",
          query: {},
          cookie: "",
          workspace: "",
          workspaceFromCookie: "",
          authorization: "",
        };
        if (!text || !text.trim()) {
          return result;
        }
        const urlMatch = text.match(/curl\s+(?:-X\s+\w+\s+)?(?:'([^']+)'|"([^"]+)"|(\S+))/i);
        if (urlMatch) {
          result.url = urlMatch[1] || urlMatch[2] || urlMatch[3] || "";
          try {
            const parsedUrl = new URL(result.url);
            const params = parsedUrl.searchParams;
            result.query.platform = params.get("platform") || "";
            result.query.page = params.get("page") || "";
            result.query.sortField = params.get("order_by") || params.get("sortField") || "";
            result.query.sortOrder = params.get("order") || params.get("sortOrder") || "";
            if (!result.query.platform) {
              const pathMatch = parsedUrl.pathname.match(/\/discover\/explore\/([^/]+)\/influencers\/?/i);
              if (pathMatch) {
                result.query.platform = pathMatch[1];
              }
            }
          } catch (err) {
            result.url = result.url.trim();
          }
        }

        const headerRegex = /-H\s+(['"])([\s\S]*?)\1/g;
        let headerMatch;
        while ((headerMatch = headerRegex.exec(text)) !== null) {
          const headerValue = headerMatch[2] || "";
          const separatorIndex = headerValue.indexOf(":");
          if (separatorIndex === -1) {
            continue;
          }
          const name = headerValue.slice(0, separatorIndex).trim().toLowerCase();
          const value = headerValue.slice(separatorIndex + 1).trim();
          if (name === "cookie" && value) {
            result.cookie = value;
          }
          if (name === "ft-workspace" && value) {
            result.workspace = value;
          }
          if (name === "authorization" && value) {
            result.authorization = value;
          }
        }

        if (!result.cookie) {
          const cookieMatch = text.match(/(?:-b|--cookie)\s+(['"])([\s\S]*?)\1/);
          if (cookieMatch) {
            result.cookie = cookieMatch[2] || "";
          }
        }

        if (result.cookie) {
          const workspaceMatch = result.cookie.match(/(?:^|;\s*)workspace_code=([^;]+)/i);
          if (workspaceMatch) {
            result.workspaceFromCookie = workspaceMatch[1];
          }
        }

        return result;
      }

      function applyFeaturingPrefill(parsed) {
        if (!parsed) {
          return;
        }
        if (parsed.query.platform) {
          featuringPlatform.value = parsed.query.platform;
        }
        if (parsed.query.page) {
          featuringPage.value = parsed.query.page;
        }
        if (parsed.query.sortField) {
          featuringSortField.value = parsed.query.sortField;
        }
        if (parsed.query.sortOrder) {
          featuringSortOrder.value = parsed.query.sortOrder;
        }
        if (parsed.workspace) {
          featuringWorkspace.value = parsed.workspace;
        } else if (!featuringWorkspace.value && parsed.workspaceFromCookie) {
          featuringWorkspace.value = parsed.workspaceFromCookie;
        }
        if (parsed.authorization) {
          featuringAuthorization.value = parsed.authorization;
        }
        if (parsed.cookie) {
          featuringCookie.value = parsed.cookie;
        }
      }

      function saveFeaturingDefaults() {
        if (!featuringRemember.checked) {
          localStorage.removeItem("featuringDebugDefaults");
          return;
        }
        const payload = {
          platform: featuringPlatform.value,
          page: featuringPage.value,
          sortField: featuringSortField.value,
          sortOrder: featuringSortOrder.value,
          workspace: featuringWorkspace.value,
          authorization: featuringAuthorization.value,
          cookie: featuringCookie.value,
        };
        localStorage.setItem("featuringDebugDefaults", JSON.stringify(payload));
      }

      function loadFeaturingDefaults() {
        try {
          const stored = localStorage.getItem("featuringDebugDefaults");
          if (!stored) {
            return;
          }
          const payload = JSON.parse(stored);
          if (payload.platform) {
            featuringPlatform.value = payload.platform;
          }
          if (payload.page) {
            featuringPage.value = payload.page;
          }
          if (payload.sortField) {
            featuringSortField.value = payload.sortField;
          }
          if (payload.sortOrder) {
            featuringSortOrder.value = payload.sortOrder;
          }
          if (payload.workspace) {
            featuringWorkspace.value = payload.workspace;
          }
          if (payload.authorization) {
            featuringAuthorization.value = payload.authorization;
          }
          if (payload.cookie) {
            featuringCookie.value = payload.cookie;
          }
        } catch (err) {
          localStorage.removeItem("featuringDebugDefaults");
        }
      }

      function setRequestUrlPreview(target, url) {
        target.value = url || "";
      }

      function setStatus(target, message, type) {
        target.textContent = message;
        target.className = "status" + (type ? " " + type : "");
      }

      function renderChips(target, items, className) {
        target.innerHTML = "";
        if (!items || items.length === 0) {
          target.innerHTML = "<span class=\"chip alt\">(empty)</span>";
          return;
        }
        items.forEach((item) => {
          const chip = document.createElement("span");
          chip.className = "chip" + (className ? " " + className : "");
          chip.textContent = item;
          target.appendChild(chip);
        });
      }

      function renderUsers(target, users) {
        target.innerHTML = "";
        if (!users || users.length === 0) {
          target.innerHTML = "<div class=\"list-empty\">(empty)</div>";
          return;
        }
        users.forEach((user) => {
          const item = document.createElement("div");
          item.className = "list-item";
          const primary = document.createElement("div");
          primary.className = "list-primary";
          primary.textContent = user.username || "(unknown)";
          const meta = document.createElement("div");
          meta.className = "list-meta";
          const parts = [];
          if (user.fullName) {
            parts.push(user.fullName);
          }
          if (typeof user.followerCount === "number") {
            parts.push("followers " + user.followerCount);
          }
          if (user.isVerified) {
            parts.push("verified");
          }
          if (user.isPrivate) {
            parts.push("private");
          }
          meta.textContent = parts.join(" · ");
          item.appendChild(primary);
          if (meta.textContent) {
            item.appendChild(meta);
          }
          target.appendChild(item);
        });
      }


      async function fetchKeywordTemplate(version) {
        try {
          const response = await fetch("/instagram/keyword-prompt", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId: "", version }),
          });
          if (!response.ok) {
            return "";
          }
          const data = await response.json();
          return data.template || "";
        } catch (err) {
          return "";
        }
      }

      async function fetchDmTemplate(version) {
        try {
          const response = await fetch("/instagram/dm-prompt", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ version }),
          });
          if (!response.ok) {
            return "";
          }
          const data = await response.json();
          return data.template || "";
        } catch (err) {
          return "";
        }
      }

      async function fetchPriceTemplate(version) {
        try {
          const response = await fetch("/instagram/price-prompt", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: "", version }),
          });
          if (!response.ok) {
            return "";
          }
          const data = await response.json();
          return data.template || "";
        } catch (err) {
          return "";
        }
      }

      async function fillKeywordCustomPrompt(selectEl, inputEl, version, previewTarget, payloadBuilder) {
        if (selectEl.value !== "custom") {
          return;
        }
        if (inputEl.value.trim()) {
          return;
        }
        const template = await fetchKeywordTemplate(version);
        if (!template) {
          return;
        }
        inputEl.value = template;
        setRequestPreview(previewTarget, payloadBuilder());
      }

      async function fillPriceCustomPrompt(selectEl, inputEl, version, previewTarget, payloadBuilder) {
        if (selectEl.value !== "custom") {
          return;
        }
        if (inputEl.value.trim()) {
          return;
        }
        const template = await fetchPriceTemplate(version);
        if (!template) {
          return;
        }
        inputEl.value = template;
        setRequestPreview(previewTarget, payloadBuilder());
      }

      async function fillDmCustomPrompt(selectEl, inputEl, version, previewTarget, payloadBuilder) {
        if (selectEl.value !== "custom") {
          return;
        }
        if (inputEl.value.trim()) {
          return;
        }
        const template = await fetchDmTemplate(version);
        if (!template) {
          return;
        }
        inputEl.value = template;
        setRequestPreview(previewTarget, payloadBuilder());
      }

      function updateRequestPreviews() {
        syncLastVersions();
        toggleCustomField(keywordVersionSelect, keywordCustomPromptField);
        toggleCustomField(priceVersionSelect, priceCustomPromptField);
        toggleCustomField(dmKeywordVersionSelect, dmKeywordCustomPromptField);
        toggleCustomField(dmVersionSelect, dmCustomPromptField);
        keywordUserOptions.classList.toggle("hidden", !keywordUserExpand.checked);
        setRequestPreview(profileRequestOutput, buildProfilePayload());
        setRequestUrlPreview(profileUrlOutput, buildProfileUrl());
        setRequestPreview(keywordRequestOutput, buildKeywordPayload());
        setRequestPreview(priceRequestOutput, buildPricePayload());
        updatePricePayloadPreview();
        setRequestPreview(dmRequestOutput, buildDmPayload());
        setRequestUrlPreview(keywordUserRequestOutput, buildKeywordUserRequestUrl());
        setRequestUrlPreview(featuringRequestOutput, buildFeaturingRequestUrl());
        featuringHeadersOutput.value = JSON.stringify(buildFeaturingHeaders(), null, 2);
        saveFeaturingDefaults();
        const keywordVersion = resolveVersion(
          keywordVersionSelect,
          lastKeywordVersion,
          DEFAULT_KEYWORD_VERSION,
        );
        const priceVersion = resolveVersion(
          priceVersionSelect,
          lastPriceVersion,
          DEFAULT_PRICE_VERSION,
        );
        const dmKeywordVersion = resolveVersion(
          dmKeywordVersionSelect,
          lastDmKeywordVersion,
          DEFAULT_KEYWORD_VERSION,
        );
        const dmVersion = resolveVersion(dmVersionSelect, lastDmVersion, DEFAULT_DM_VERSION);
        void fillKeywordCustomPrompt(
          keywordVersionSelect,
          customKeywordPromptInput,
          keywordVersion,
          keywordRequestOutput,
          buildKeywordPayload,
        );
        void fillPriceCustomPrompt(
          priceVersionSelect,
          customPricePromptInput,
          priceVersion,
          priceRequestOutput,
          buildPricePayload,
        );
        void fillKeywordCustomPrompt(
          dmKeywordVersionSelect,
          customDmKeywordPromptInput,
          dmKeywordVersion,
          dmRequestOutput,
          buildDmPayload,
        );
        void fillDmCustomPrompt(
          dmVersionSelect,
          customDmPromptInput,
          dmVersion,
          dmRequestOutput,
          buildDmPayload,
        );
      }

      function handlePriceImageFileChange() {
        const file = priceImageFileInput.files && priceImageFileInput.files[0];
        if (!file) {
          priceImageFileNote.textContent = "No file selected.";
          priceImagePreview.src = "";
          priceImagePreviewWrap.classList.add("hidden");
          priceImageDataUrl = "";
          updateRequestPreviews();
          return;
        }
        const sizeKb = Math.round(file.size / 1024);
        priceImageFileNote.textContent = file.name + " (" + sizeKb + " KB)";
        const reader = new FileReader();
        reader.onload = () => {
          const result = typeof reader.result === "string" ? reader.result : "";
          if (!result) {
            priceImageFileNote.textContent = "Failed to read file.";
            return;
          }
          priceImageDataUrl = result;
          priceImageUrlInput.value = "";
          priceImagePreview.src = result;
          priceImagePreviewWrap.classList.remove("hidden");
          updateRequestPreviews();
        };
        reader.onerror = () => {
          priceImageFileNote.textContent = "Failed to read file.";
        };
        reader.readAsDataURL(file);
      }

      async function runProfileRequest() {
        const endpoint = profileEndpointSelect.value || "profiles";
        const payload = buildProfilePayload();
        const identifier = isProfileGetEndpoint(endpoint) ? payload.username : payload.userId;
        if (!identifier) {
          setStatus(profileStatusEl, "Username is required for profile requests.", "error");
          return;
        }
        const url = buildProfileUrl();
        setStatus(profileStatusEl, "Requesting " + endpoint + "...", "info");
        profileRawOutput.textContent = "Loading...";

        try {
          const requestInit = isProfileGetEndpoint(endpoint)
            ? { method: "GET" }
            : {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              };
          const response = await fetch(url, requestInit);
          const text = await response.text();
          setRawOutput(profileRawOutput, text);
          if (!response.ok) {
            setStatus(profileStatusEl, "Request failed: " + response.status, "error");
            return;
          }
          setStatus(profileStatusEl, endpoint + " request complete.", "success");
        } catch (err) {
          setStatus(profileStatusEl, "Network error: " + err.message, "error");
        }
      }

      async function runBatchProfileRequest() {
        if (batchInFlight) {
          return;
        }
        const usernames = parseBatchUsernames(batchUsernamesInput.value);
        if (usernames.length === 0) {
          setStatus(batchProfileStatusEl, "Username list is required.", "error");
          return;
        }
        batchInFlight = true;
        batchAbortController = new AbortController();
        batchResults = [];
        setBatchControls(true);
        setStatus(batchProfileStatusEl, "Starting batch (" + usernames.length + " users)...", "info");
        batchProfileRawOutput.textContent = "Loading...";

        for (let index = 0; index < usernames.length; index += 1) {
          if (!batchInFlight) {
            break;
          }
          const username = usernames[index];
          const url = "/instagram/profile-by-username?username=" + encodeURIComponent(username);
          setStatus(
            batchProfileStatusEl,
            "Fetching " + username + " (" + (index + 1) + "/" + usernames.length + ")...",
            "info",
          );
          const entry = {
            username,
            url,
            startedAt: new Date().toISOString(),
          };

          try {
            const response = await fetch(url, {
              method: "GET",
              signal: batchAbortController.signal,
            });
            const text = await response.text();
            entry.status = response.status;
            entry.ok = response.ok;
            entry.finishedAt = new Date().toISOString();
            try {
              entry.data = JSON.parse(text);
            } catch (err) {
              entry.raw = text;
            }
          } catch (err) {
            if (err.name === "AbortError") {
              entry.error = "aborted";
            } else {
              entry.error = err.message;
            }
          }
          batchResults.push(entry);
          setRawOutput(
            batchProfileRawOutput,
            JSON.stringify(
              {
                total: usernames.length,
                completed: batchResults.length,
                results: batchResults,
              },
              null,
              2,
            ),
          );

          if (index < usernames.length - 1 && batchInFlight) {
            const delayMs = randomDelayMs();
            setStatus(
              batchProfileStatusEl,
              "Waiting " + Math.round(delayMs / 1000) + "s before next request...",
              "info",
            );
            await wait(delayMs);
          }
        }

        if (!batchInFlight) {
          setStatus(batchProfileStatusEl, "Batch stopped.", "error");
        } else {
          setStatus(batchProfileStatusEl, "Batch complete.", "success");
        }
        batchInFlight = false;
        batchAbortController = null;
        setBatchControls(false);
      }

      function stopBatchProfileRequest() {
        if (!batchInFlight) {
          return;
        }
        batchInFlight = false;
        if (batchAbortController) {
          batchAbortController.abort();
        }
        setBatchControls(false);
      }

      async function runDmPromptPreview() {
        syncLastVersions();
        const version = resolveVersion(dmVersionSelect, lastDmVersion, DEFAULT_DM_VERSION);
        setStatus(dmPromptStatusEl, "Fetching DM prompt template...", "info");
        dmPromptOutput.value = "Loading...";

        try {
          const response = await fetch("/instagram/dm-prompt", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ version }),
          });
          const text = await response.text();
          if (!response.ok) {
            dmPromptOutput.value = text || "(failed)";
            setStatus(dmPromptStatusEl, "Request failed: " + response.status, "error");
            return;
          }
          let data = null;
          try {
            data = JSON.parse(text);
          } catch (err) {
            dmPromptOutput.value = "(invalid response)";
            setStatus(dmPromptStatusEl, "Failed to parse JSON response.", "error");
            return;
          }
          dmPromptOutput.value = data.template || "(empty template)";
          setStatus(dmPromptStatusEl, "DM prompt template updated.", "success");
        } catch (err) {
          setStatus(dmPromptStatusEl, "Network error: " + err.message, "error");
          dmPromptOutput.value = "(network error)";
        }
      }

      async function runPromptPreview() {
        const payload = buildKeywordPayload();
        if (!payload.userId) {
          setStatus(promptStatusEl, "Username is required for prompt preview.", "error");
          return;
        }
        setStatus(promptStatusEl, "Fetching prompt preview...", "info");
        templateOutput.value = "Loading...";
        promptOutput.value = "Loading...";

        try {
          const response = await fetch("/instagram/keyword-prompt", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              userId: payload.userId,
              version: payload.version,
              customPrompt: payload.customPrompt,
            }),
          });
          if (!response.ok) {
            setStatus(promptStatusEl, "Prompt preview failed: " + response.status, "error");
            templateOutput.value = "(failed)";
            promptOutput.value = "(failed)";
            return;
          }
          const data = await response.json();
          templateOutput.value = data.template || "(empty template)";
          promptOutput.value = data.prompt || "(empty prompt)";
          setStatus(promptStatusEl, "Prompt preview updated.", "success");
        } catch (err) {
          setStatus(promptStatusEl, "Network error: " + err.message, "error");
        }
      }

      async function runPricePromptPreview() {
        syncLastVersions();
        const payload = buildPricePayload();
        const version = resolveVersion(priceVersionSelect, lastPriceVersion, DEFAULT_PRICE_VERSION);
        setStatus(pricePromptStatusEl, "Fetching price prompt preview...", "info");
        priceTemplateOutput.value = "Loading...";
        pricePromptOutput.value = "Loading...";

        try {
          const response = await fetch("/instagram/price-prompt", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              text: payload.text,
              version,
              customPrompt: payload.customPrompt,
            }),
          });
          if (!response.ok) {
            setStatus(pricePromptStatusEl, "Prompt preview failed: " + response.status, "error");
            priceTemplateOutput.value = "(failed)";
            pricePromptOutput.value = "(failed)";
            return;
          }
          const data = await response.json();
          lastPricePrompt = data.prompt || "";
          priceTemplateOutput.value = data.template || "(empty template)";
          pricePromptOutput.value = lastPricePrompt || "(empty prompt)";
          updatePricePayloadPreview();
          setStatus(pricePromptStatusEl, "Price prompt preview updated.", "success");
        } catch (err) {
          setStatus(pricePromptStatusEl, "Network error: " + err.message, "error");
        }
      }

      async function runKeywordExtraction() {
        const payload = buildKeywordPayload();
        if (!payload.userId) {
          setStatus(keywordStatusEl, "Username is required for keyword extraction.", "error");
          return;
        }
        setStatus(keywordStatusEl, "Requesting keywords...", "info");
        keywordRawOutput.textContent = "Loading...";
        keywordChips.innerHTML = "";

        try {
          const response = await fetch("/instagram/extract-keywords", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const text = await response.text();
          setRawOutput(keywordRawOutput, text);
          if (!response.ok) {
            setStatus(keywordStatusEl, "Request failed: " + response.status, "error");
            return;
          }
          let data = null;
          try {
            data = JSON.parse(text);
          } catch (err) {
            setStatus(keywordStatusEl, "Failed to parse JSON response.", "error");
            return;
          }
          renderChips(keywordChips, data.keywords, "");
          setStatus(keywordStatusEl, "Keyword extraction complete.", "success");
        } catch (err) {
          setStatus(keywordStatusEl, "Network error: " + err.message, "error");
        }
      }

      async function runPriceExtraction() {
        const payload = buildPricePayload();
        if (!payload.text && !payload.imageUrl) {
          setStatus(priceStatusEl, "Text or image URL is required for price extraction.", "error");
          return;
        }
        setStatus(priceStatusEl, "Extracting prices...", "info");
        priceOutput.value = "Loading...";
        priceRawOutput.textContent = "Loading...";

        try {
          const response = await fetch("/instagram/extract-prices", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const text = await response.text();
          setRawOutput(priceRawOutput, text);
          if (!response.ok) {
            setStatus(priceStatusEl, "Request failed: " + response.status, "error");
            priceOutput.value = "(failed)";
            return;
          }
          const trimmed = (text || "").trim();
          if (!trimmed) {
            setStatus(priceStatusEl, "Empty response.", "error");
            priceOutput.value = "(empty)";
            return;
          }
          try {
            const data = JSON.parse(trimmed);
            priceOutput.value = JSON.stringify(data, null, 2);
            setStatus(priceStatusEl, "Price extraction complete (JSON parsed).", "success");
          } catch (err) {
            priceOutput.value = text;
            setStatus(priceStatusEl, "Price extraction complete (raw output).", "success");
          }
        } catch (err) {
          setStatus(priceStatusEl, "Network error: " + err.message, "error");
          priceOutput.value = "(network error)";
        }
      }

      async function runDmGeneration() {
        const payload = buildDmPayload();
        if (!payload.userId) {
          setStatus(dmStatusEl, "Username is required for DM generation.", "error");
          return;
        }
        setStatus(dmStatusEl, "Generating DM...", "info");
        dmOutput.value = "Loading...";
        dmRawOutput.textContent = "Loading...";
        dmSummaryOutput.value = "";
        dmMoodChips.innerHTML = "";
        dmContentChips.innerHTML = "";
        dmToneChips.innerHTML = "";

        try {
          const response = await fetch("/instagram/generate-dm", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const text = await response.text();
          setRawOutput(dmRawOutput, text);
          if (!response.ok) {
            setStatus(dmStatusEl, "Request failed: " + response.status, "error");
            dmOutput.value = "(failed)";
            return;
          }
          let data = null;
          try {
            data = JSON.parse(text);
          } catch (err) {
            setStatus(dmStatusEl, "Failed to parse JSON response.", "error");
            dmOutput.value = "(invalid response)";
            return;
          }
          dmOutput.value = data.message || "(empty message)";
          renderChips(dmMoodChips, data.moodKeywords, "");
          renderChips(dmContentChips, data.contentKeywords, "");
          renderChips(dmToneChips, data.toneKeywords, "alt");
          dmSummaryOutput.value = data.impressionSummary || "(empty summary)";
          setStatus(dmStatusEl, "DM generation complete.", "success");
        } catch (err) {
          setStatus(dmStatusEl, "Network error: " + err.message, "error");
          dmOutput.value = "(network error)";
        }
      }

      async function runKeywordUserSearch() {
        const url = buildKeywordUserRequestUrl();
        if (!url) {
          setStatus(keywordUserStatusEl, "Keyword query is required.", "error");
          return;
        }
        setStatus(keywordUserStatusEl, "Searching users...", "info");
        keywordUserRawOutput.textContent = "Loading...";
        keywordUserList.innerHTML = "";

        try {
          const response = await fetch(url);
          const text = await response.text();
          setRawOutput(keywordUserRawOutput, text);
          if (!response.ok) {
            setStatus(keywordUserStatusEl, "Request failed: " + response.status, "error");
            return;
          }
          let data = null;
          try {
            data = JSON.parse(text);
          } catch (err) {
            setStatus(keywordUserStatusEl, "Failed to parse JSON response.", "error");
            return;
          }
          renderUsers(keywordUserList, data);
          setStatus(keywordUserStatusEl, "User search complete.", "success");
        } catch (err) {
          setStatus(keywordUserStatusEl, "Network error: " + err.message, "error");
        }
      }

      async function runFeaturingRequest() {
        const url = buildFeaturingRequestUrl();
        const headers = buildFeaturingHeaders();
        if (!headers["Ft-Workspace"]) {
          setStatus(featuringStatusEl, "Ft-Workspace header is required.", "error");
          return;
        }
        if (!headers["X-Featuring-Authorization"]) {
          setStatus(featuringStatusEl, "Authorization header is required.", "error");
          return;
        }
        setStatus(featuringStatusEl, "Requesting Featuring influencers...", "info");
        featuringRawOutput.textContent = "Loading...";

        try {
          const response = await fetch(url, {
            method: "GET",
            headers,
          });
          const text = await response.text();
          setRawOutput(featuringRawOutput, text);
          if (!response.ok) {
            setStatus(featuringStatusEl, "Request failed: " + response.status, "error");
            return;
          }
          setStatus(featuringStatusEl, "Featuring request complete.", "success");
        } catch (err) {
          setStatus(featuringStatusEl, "Network error: " + err.message, "error");
        }
      }

      function runFeaturingCurlPrefill() {
        const parsed = parseCurlInput(featuringCurl.value || "");
        if (!parsed.url && !parsed.cookie && !parsed.workspace && !parsed.workspaceFromCookie) {
          setStatus(featuringStatusEl, "No curl data found to parse.", "error");
          return;
        }
        applyFeaturingPrefill(parsed);
        updateRequestPreviews();
        setStatus(featuringStatusEl, "Prefill updated from curl.", "success");
      }

      async function loadVersions() {
        try {
          const response = await fetch("/instagram/keyword-versions");
          const versions = response.ok ? await response.json() : [];
          populateSelect(keywordVersionSelect, versions, "v2");
          populateSelect(dmKeywordVersionSelect, versions, "v2", "v3");
          keywordVersionsOutput.value = JSON.stringify(versions || [], null, 2);
          setStatus(keywordVersionsStatusEl, "Keyword versions loaded.", "success");
        } catch (err) {
          populateSelect(keywordVersionSelect, [], "v2");
          populateSelect(dmKeywordVersionSelect, [], "v2", "v3");
          keywordVersionsOutput.value = "[]";
          setStatus(keywordVersionsStatusEl, "Failed to load keyword versions.", "error");
        }

        try {
          const response = await fetch("/instagram/price-versions");
          const versions = response.ok ? await response.json() : [];
          populateSelect(priceVersionSelect, versions, "v1");
          priceVersionsOutput.value = JSON.stringify(versions || [], null, 2);
          setStatus(priceVersionsStatusEl, "Price versions loaded.", "success");
        } catch (err) {
          populateSelect(priceVersionSelect, [], "v1");
          priceVersionsOutput.value = "[]";
          setStatus(priceVersionsStatusEl, "Failed to load price versions.", "error");
        }

        try {
          const response = await fetch("/instagram/dm-versions");
          const versions = response.ok ? await response.json() : [];
          populateSelect(dmVersionSelect, versions, "v1");
          dmVersionsOutput.value = JSON.stringify(versions || [], null, 2);
          setStatus(dmVersionsStatusEl, "DM versions loaded.", "success");
        } catch (err) {
          populateSelect(dmVersionSelect, [], "v1");
          dmVersionsOutput.value = "[]";
          setStatus(dmVersionsStatusEl, "Failed to load DM versions.", "error");
        }

        updateRequestPreviews();
      }

      function populateSelect(selectEl, versions, fallback, preferred) {
        selectEl.innerHTML = "";
        let preferredFound = false;
        if (!versions || versions.length === 0) {
          const option = document.createElement("option");
          option.value = fallback;
          option.textContent = fallback + " (default)";
          selectEl.appendChild(option);
        } else {
          versions.forEach((version, index) => {
            const option = document.createElement("option");
            option.value = version;
            if (preferred && version === preferred) {
              option.textContent = version + " (default)";
              option.selected = true;
              preferredFound = true;
            } else {
              option.textContent = version + (!preferred && index === 0 ? " (default)" : "");
            }
            selectEl.appendChild(option);
          });
        }
        const custom = document.createElement("option");
        custom.value = "custom";
        custom.textContent = "custom";
        selectEl.appendChild(custom);
        if (preferred && !preferredFound) {
          const match = Array.from(selectEl.options).some((option) => option.value === preferred);
          if (match) {
            selectEl.value = preferred;
          }
        }
      }

      function copyTextToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
          return navigator.clipboard.writeText(text);
        }
        const temp = document.createElement("textarea");
        temp.value = text;
        temp.setAttribute("readonly", "");
        temp.style.position = "absolute";
        temp.style.left = "-9999px";
        document.body.appendChild(temp);
        temp.select();
        const ok = document.execCommand("copy");
        document.body.removeChild(temp);
        if (!ok) {
          throw new Error("Copy not permitted");
        }
        return Promise.resolve();
      }

      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const tab = button.dataset.tab;
          tabButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          tabPanels.forEach((panel) => {
            panel.classList.toggle("active", panel.dataset.panel === tab);
          });
        });
      });

      copyButtons.forEach((button) => {
        button.addEventListener("click", async () => {
          const target = button.dataset.copy;
          let text = "";
          const rawText = (el) => (el ? el.dataset.raw || el.textContent : "");
          if (target === "profile-url") {
            text = profileUrlOutput.value;
          } else if (target === "profile-request") {
            text = profileRequestOutput.value;
          } else if (target === "profile-raw") {
            text = rawText(profileRawOutput);
          } else if (target === "batch-profile-raw") {
            text = rawText(batchProfileRawOutput);
          } else if (target === "keywords") {
            text = Array.from(keywordChips.querySelectorAll(".chip"))
              .map((chip) => chip.textContent)
              .join(", ");
          } else if (target === "keyword-raw") {
            text = rawText(keywordRawOutput);
          } else if (target === "keyword-request") {
            text = keywordRequestOutput.value;
          } else if (target === "template") {
            text = templateOutput.value;
          } else if (target === "prompt") {
            text = promptOutput.value;
          } else if (target === "price-json") {
            text = priceOutput.value;
          } else if (target === "price-raw") {
            text = rawText(priceRawOutput);
          } else if (target === "price-request") {
            text = priceRequestOutput.value;
          } else if (target === "price-template") {
            text = priceTemplateOutput.value;
          } else if (target === "price-prompt") {
            text = pricePromptOutput.value;
          } else if (target === "dm") {
            text = dmOutput.value;
          } else if (target === "dm-summary") {
            text = dmSummaryOutput.value;
          } else if (target === "dm-prompt") {
            text = dmPromptOutput.value;
          } else if (target === "dm-raw") {
            text = rawText(dmRawOutput);
          } else if (target === "dm-request") {
            text = dmRequestOutput.value;
          } else if (target === "keyword-versions") {
            text = keywordVersionsOutput.value;
          } else if (target === "price-versions") {
            text = priceVersionsOutput.value;
          } else if (target === "dm-versions") {
            text = dmVersionsOutput.value;
          } else if (target === "keyword-users") {
            text = Array.from(keywordUserList.querySelectorAll(".list-primary"))
              .map((item) => item.textContent)
              .join(", ");
          } else if (target === "keyword-users-raw") {
            text = rawText(keywordUserRawOutput);
          } else if (target === "keyword-users-request") {
            text = keywordUserRequestOutput.value;
          } else if (target === "featuring-url") {
            text = featuringRequestOutput.value;
          } else if (target === "featuring-headers") {
            text = featuringHeadersOutput.value;
          } else if (target === "featuring-raw") {
            text = rawText(featuringRawOutput);
          }

          if (!text) {
            return;
          }
          await copyTextToClipboard(text);
        });
      });

      profileBtn.addEventListener("click", runProfileRequest);
      batchProfileBtn.addEventListener("click", runBatchProfileRequest);
      batchProfileStopBtn.addEventListener("click", stopBatchProfileRequest);
      keywordBtn.addEventListener("click", runKeywordExtraction);
      promptBtn.addEventListener("click", runPromptPreview);
      priceBtn.addEventListener("click", runPriceExtraction);
      pricePromptBtn.addEventListener("click", runPricePromptPreview);
      priceImageFileInput.addEventListener("change", handlePriceImageFileChange);
      dmBtn.addEventListener("click", runDmGeneration);
      dmPromptBtn.addEventListener("click", runDmPromptPreview);
      keywordUserBtn.addEventListener("click", runKeywordUserSearch);
      featuringBtn.addEventListener("click", runFeaturingRequest);
      featuringParseBtn.addEventListener("click", runFeaturingCurlPrefill);
      keywordVersionsBtn.addEventListener("click", loadVersions);
      priceVersionsBtn.addEventListener("click", loadVersions);
      dmVersionsBtn.addEventListener("click", loadVersions);

      [
        userIdInput,
        profileEndpointSelect,
        keywordVersionSelect,
        customKeywordPromptInput,
        keywordIgnoreCache,
        priceTextInput,
        priceImageUrlInput,
        priceVersionSelect,
        customPricePromptInput,
        dmKeywordVersionSelect,
        customDmKeywordPromptInput,
        dmVersionSelect,
        customDmPromptInput,
        dmIgnoreCache,
        keywordQueryInput,
        keywordUserExpand,
        keywordUserMax,
        keywordUserFeedCount,
        keywordUserPages,
        batchUsernamesInput,
        featuringPlatform,
        featuringPage,
        featuringSortField,
        featuringSortOrder,
        featuringWorkspace,
        featuringAuthorization,
        featuringCookie,
        featuringCurl,
        featuringRemember,
      ].forEach((el) => {
        el.addEventListener("input", updateRequestPreviews);
        el.addEventListener("change", updateRequestPreviews);
      });

      setBatchControls(false);
      loadFeaturingDefaults();
      loadVersions();
    </script>
  </body>
</html>
